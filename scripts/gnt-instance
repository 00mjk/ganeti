#!/usr/bin/python
#

# Copyright (C) 2006, 2007 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.


import sys
import os
from optparse import make_option
from cStringIO import StringIO

from ganeti.cli import *
from ganeti import opcodes
from ganeti import logger
from ganeti import constants
from ganeti import utils


def ListInstances(opts, args):
  """List nodes and their properties.

  """
  if opts.output is None:
    selected_fields = ["name", "os", "pnode", "admin_state",
                       "oper_state", "oper_ram"]
  else:
    selected_fields = opts.output.split(",")

  op = opcodes.OpQueryInstances(output_fields=selected_fields)
  output = SubmitOpCode(op)

  if not opts.no_headers:
    headers = {"name": "Instance", "os": "OS", "pnode": "Primary_node",
               "snodes": "Secondary_Nodes", "admin_state": "Autostart",
               "oper_state": "Status", "admin_ram": "Configured_memory",
               "oper_ram": "Memory", "disk_template": "Disk_template",
               "ip": "IP Address", "mac": "MAC Address",
               "bridge": "Bridge"}
  else:
    headers = None

  if opts.human_readable:
    unitfields = ["admin_ram", "oper_ram"]
  else:
    unitfields = None

  numfields = ["admin_ram", "oper_ram"]

  data = GenerateTable(separator=opts.separator, headers=headers,
                       fields=selected_fields, unitfields=unitfields,
                       numfields=numfields, data=output)

  for line in data:
    logger.ToStdout(line)

  return 0


def AddInstance(opts, args):
  """Add an instance to the cluster.

  Args:
    opts - class with options as members
    args - list with a single element, the instance name
  Opts used:
    mem - amount of memory to allocate to instance (MiB)
    size - amount of disk space to allocate to instance (MiB)
    os - which OS to run on instance
    node - node to run new instance on

  """
  instance = args[0]

  op = opcodes.OpCreateInstance(instance_name=instance, mem_size=opts.mem,
                                disk_size=opts.size, swap_size=opts.swap,
                                disk_template=opts.disk_template,
                                mode=constants.INSTANCE_CREATE,
                                os_type=opts.os, pnode=opts.node,
                                snode=opts.snode, vcpus=opts.vcpus,
                                ip=opts.ip, bridge=opts.bridge, start=True,
                                wait_for_sync=opts.wait_for_sync)
  SubmitOpCode(op)
  return 0


def ReinstallInstance(opts, args):
  """Reinstall an instance.

  Args:
    opts - class with options as members
    args - list containing a single element, the instance name

  """
  instance_name = args[0]

  if not opts.force:
    usertext = ("This will reinstall the instance %s and remove "
                "all data. Continue?") % instance_name
    if not opts._ask_user(usertext):
      return 1

  op = opcodes.OpReinstallInstance(instance_name=instance_name,
                                   os_type=opts.os)
  SubmitOpCode(op)

  return 0


def RemoveInstance(opts, args):
  """Remove an instance.

  Args:
    opts - class with options as members
    args - list containing a single element, the instance name

  """
  instance_name = args[0]
  force = opts.force

  if not force:
    usertext = ("This will remove the volumes of the instance %s"
                " (including mirrors), thus removing all the data"
                " of the instance. Continue?") % instance_name
    if not opts._ask_user(usertext):
      return 1

  op = opcodes.OpRemoveInstance(instance_name=instance_name)
  SubmitOpCode(op)
  return 0


def ActivateDisks(opts, args):
  """Activate an instance's disks.

  This serves two purposes:
    - it allows one (as long as the instance is not running) to mount
    the disks and modify them from the node
    - it repairs inactive secondary drbds

  """
  instance_name = args[0]
  op = opcodes.OpActivateInstanceDisks(instance_name=instance_name)
  disks_info = SubmitOpCode(op)
  for host, iname, nname in disks_info:
    print "%s:%s:%s" % (host, iname, nname)
  return 0


def DeactivateDisks(opts, args):
  """Command-line interface for _ShutdownInstanceBlockDevices.

  This function takes the instance name, looks for its primary node
  and the tries to shutdown its block devices on that node.

  """
  instance_name = args[0]
  op = opcodes.OpDeactivateInstanceDisks(instance_name=instance_name)
  SubmitOpCode(op)
  return 0


def StartupInstance(opts, args):
  """Shutdown an instance.

  Args:
    opts - class with options as members
    args - list containing a single element, the instance name

  """
  instance_name = args[0]
  op = opcodes.OpStartupInstance(instance_name=instance_name, force=opts.force,
                                 extra_args=opts.extra_args)
  SubmitOpCode(op)
  return 0


def ShutdownInstance(opts, args):
  """Shutdown an instance.

  Args:
    opts - class with options as members
    args - list containing a single element, the instance name

  """
  instance_name = args[0]
  op = opcodes.OpShutdownInstance(instance_name=instance_name)
  SubmitOpCode(op)
  return 0


def AddMDDRBDComponent(opts, args):
  """Add a new component to a remote_raid1 disk.

  Args:
    opts - class with options as members
    args - list with a single element, the instance name

  """
  op = opcodes.OpAddMDDRBDComponent(instance_name=args[0],
                                    disk_name=opts.disk,
                                    remote_node=opts.node)
  SubmitOpCode(op)
  return 0


def RemoveMDDRBDComponent(opts, args):
  """Remove a component from a remote_raid1 disk.

  Args:
    opts - class with options as members
    args - list with a single element, the instance name

  """
  op = opcodes.OpRemoveMDDRBDComponent(instance_name=args[0],
                                       disk_name=opts.disk,
                                       disk_id=opts.port)
  SubmitOpCode(op)
  return 0


def ReplaceDisks(opts, args):
  """Replace the disks of an instance

  Args:
    opts - class with options as members
    args - list with a single element, the instance name

  """
  instance_name = args[0]
  new_secondary = opts.new_secondary
  op = opcodes.OpReplaceDisks(instance_name=args[0],
                              remote_node=opts.new_secondary)
  SubmitOpCode(op)
  return 0


def FailoverInstance(opts, args):
  """Failover an instance.

  The failover is done by shutting it down on its present node and
  starting it on the secondary.

  Args:
    opts - class with options as members
    args - list with a single element, the instance name
  Opts used:
    force - whether to failover without asking questions.

  """
  instance_name = args[0]
  force = opts.force

  if not force:
    usertext = ("Failover will happen to image %s."
                " This requires a shutdown of the instance. Continue?" %
                (instance_name,))
    if not opts._ask_user(usertext):
      return 1

  op = opcodes.OpFailoverInstance(instance_name=instance_name,
                                  ignore_consistency=opts.ignore_consistency)
  SubmitOpCode(op)
  return 0


def ConnectToInstanceConsole(opts, args):
  """Connect to the console of an instance.

  Args:
    opts - class with options as members
    args - list with a single element, the instance name

  """
  instance_name = args[0]

  op = opcodes.OpConnectConsole(instance_name=instance_name)
  node, console_cmd = SubmitOpCode(op)
  # drop lock and exec so other commands can run while we have console
  utils.Unlock("cmd")
  try:
    os.execv("/usr/bin/ssh", ["ssh", "-qt", node, console_cmd])
  finally:
    sys.stderr.write("Can't run console command %s on node %s" %
                     (console_cmd, node))
    os._exit(1)


def _FormatBlockDevInfo(buf, dev, indent_level):
  """Show block device information.

  This is only used by ShowInstanceConfig(), but it's too big to be
  left for an inline definition.

  """
  def helper(buf, dtype, status):
    """Format one line for phsyical device status."""
    if not status:
      buf.write("not active\n")
    else:
      (path, major, minor, syncp, estt, degr) = status
      buf.write("%s (%d:%d)" % (path, major, minor))
      if dtype in ("md_raid1", "drbd"):
        if syncp is not None:
          sync_text = "*RECOVERING* %5.2f%%," % syncp
          if estt:
            sync_text += " ETA %ds" % estt
          else:
            sync_text += " ETA unknown"
        else:
          sync_text = "in sync"
        if degr:
          degr_text = "*DEGRADED*"
        else:
          degr_text = "ok"
        buf.write(" %s, status %s" % (sync_text, degr_text))
      buf.write("\n")

  if dev["iv_name"] is not None:
    data = "  - %s, " % dev["iv_name"]
  else:
    data = "  - "
  data += "type: %s" % dev["dev_type"]
  if dev["logical_id"] is not None:
    data += ", logical_id: %s" % (dev["logical_id"],)
  elif dev["physical_id"] is not None:
    data += ", physical_id: %s" % (dev["physical_id"],)
  buf.write("%*s%s\n" % (2*indent_level, "", data))
  buf.write("%*s    primary:   " % (2*indent_level, ""))
  helper(buf, dev["dev_type"], dev["pstatus"])

  if dev["sstatus"]:
    buf.write("%*s    secondary: " % (2*indent_level, ""))
    helper(buf, dev["dev_type"], dev["sstatus"])

  if dev["children"]:
    for child in dev["children"]:
      _FormatBlockDevInfo(buf, child, indent_level+1)


def ShowInstanceConfig(opts, args):
  """Compute instance run-time status.

  """
  retcode = 0
  op = opcodes.OpQueryInstanceData(instances=args)
  result = SubmitOpCode(op)

  if not result:
    logger.ToStdout("No instances.")
    return 1

  buf = StringIO()
  retcode = 0
  for instance_name in result:
    instance = result[instance_name]
    buf.write("Instance name: %s\n" % instance["name"])
    buf.write("State: configured to be %s, actual state is %s\n" %
              (instance["config_state"], instance["run_state"]))
    buf.write("  Nodes:\n")
    buf.write("    - primary: %s\n" % instance["pnode"])
    buf.write("    - secondaries: %s\n" % ", ".join(instance["snodes"]))
    buf.write("  Operating system: %s\n" % instance["os"])
    buf.write("  Hardware:\n")
    buf.write("    - memory: %dMiB\n" % instance["memory"])
    buf.write("    - NICs: %s\n" %
        ", ".join(["{MAC: %s, IP: %s, bridge: %s}" %
                   (mac, ip, bridge)
                     for mac, ip, bridge in instance["nics"]]))
    buf.write("  Block devices:\n")

    for device in instance["disks"]:
      _FormatBlockDevInfo(buf, device, 1)

  logger.ToStdout(buf.getvalue().rstrip('\n'))
  return retcode


def SetInstanceParms(opts, args):
  """Modifies an instance.

  All parameters take effect only at the next restart of the instance.

  Args:
    opts - class with options as members
    args - list with a single element, the instance name
  Opts used:
    memory - the new memory size
    vcpus - the new number of cpus

  """
  if not opts.mem and not opts.vcpus and not opts.ip and not opts.bridge:
    logger.ToStdout("Please give at least one of the parameters.")
    return 1

  op = opcodes.OpSetInstanceParms(instance_name=args[0], mem=opts.mem,
                                  vcpus=opts.vcpus, ip=opts.ip,
                                  bridge=opts.bridge)
  result = SubmitOpCode(op)

  if result:
    logger.ToStdout("Modified instance %s" % args[0])
    for param, data in result:
      logger.ToStdout(" - %-5s -> %s" % (param, data))
    logger.ToStdout("Please don't forget that these parameters take effect"
                    " only at the next start of the instance.")
  return 0


# options used in more than one cmd
node_opt = make_option("-n", "--node", dest="node", help="Target node",
                       metavar="<node>")

os_opt = cli_option("-o", "--os-type", dest="os", help="What OS to run",
                    metavar="<os>")

# this is defined separately due to readability only
add_opts = [
  DEBUG_OPT,
  node_opt,
  cli_option("-s", "--os-size", dest="size", help="Disk size",
             default=20 * 1024, type="unit", metavar="<size>"),
  cli_option("--swap-size", dest="swap", help="Swap size",
             default=4 * 1024, type="unit", metavar="<size>"),
  os_opt,
  cli_option("-m", "--memory", dest="mem", help="Memory size",
              default=128, type="unit", metavar="<mem>"),
  make_option("-p", "--cpu", dest="vcpus", help="Number of virtual CPUs",
              default=1, type="int", metavar="<PROC>"),
  make_option("-t", "--disk-template", dest="disk_template",
              help="Custom disk setup (diskless, plain, local_raid1 or"
              " remote_raid1)", default=None, metavar="TEMPL"),
  make_option("-i", "--ip", dest="ip",
              help="IP address ('none' [default], 'auto', or specify address)",
              default='none', type="string", metavar="<ADDRESS>"),
  make_option("--no-wait-for-sync", dest="wait_for_sync", default=True,
              action="store_false", help="Don't wait for sync (DANGEROUS!)"),
  make_option("--secondary-node", dest="snode",
              help="Secondary node for remote_raid1 disk layout",
              metavar="<node>"),
  make_option("-b", "--bridge", dest="bridge",
              help="Bridge to connect this instance to",
              default=None, metavar="<bridge>")
  ]

commands = {
  'add': (AddInstance, ARGS_ONE, add_opts,
          "[opts...] <name>",
          "Creates and adds a new instance to the cluster"),
  'add-mirror': (AddMDDRBDComponent, ARGS_ONE,
                [DEBUG_OPT, node_opt,
                 make_option("-b", "--disk", dest="disk", metavar="sdX",
                             help=("The name of the instance disk for which to"
                                   " add the mirror"))],
                "-n node -b disk <instance>",
                "Creates a new mirror for the instance"),
  'console': (ConnectToInstanceConsole, ARGS_ONE, [DEBUG_OPT],
              "<instance>",
              "Opens a console on the specified instance"),
  'failover': (FailoverInstance, ARGS_ONE,
               [DEBUG_OPT, FORCE_OPT,
                make_option("--ignore-consistency", dest="ignore_consistency",
                            action="store_true", default=False,
                            help="Ignore the consistency of the disks on"
                            " the secondary"),
                ],
               "[-f] <instance>",
               "Stops the instance and starts it on the backup node, using"
               " the remote mirror (only for instances of type remote_raid1)"),
  'info': (ShowInstanceConfig, ARGS_ANY, [DEBUG_OPT], "[<instance>...]",
           "Show information on the specified instance"),
  'list': (ListInstances, ARGS_NONE,
           [DEBUG_OPT, NOHDR_OPT, SEP_OPT, USEUNITS_OPT, FIELDS_OPT],
           "", "Lists the instances and their status"),
  'reinstall': (ReinstallInstance, ARGS_ONE, [DEBUG_OPT, FORCE_OPT, os_opt],
                "[-f] <instance>", "Reinstall the instance"),
  'remove': (RemoveInstance, ARGS_ONE, [DEBUG_OPT, FORCE_OPT],
             "[-f] <instance>", "Shuts down the instance and removes it"),
  'remove-mirror': (RemoveMDDRBDComponent, ARGS_ONE,
                   [DEBUG_OPT, node_opt,
                    make_option("-b", "--disk", dest="disk", metavar="sdX",
                                help=("The name of the instance disk"
                                      " for which to add the mirror")),
                    make_option("-p", "--port", dest="port", metavar="PORT",
                                help=("The port of the drbd device"
                                      " which to remove from the mirror"),
                                type="int"),
                    ],
                   "-b disk -p port <instance>",
                   "Removes a mirror from the instance"),
  'replace-disks': (ReplaceDisks, ARGS_ONE,
                    [DEBUG_OPT,
                     make_option("-n", "--new-secondary", dest="new_secondary",
                                 metavar="NODE",
                                 help=("New secondary node (if you want to"
                                       " change the secondary)"))],
                    "[-n NODE] <instance>",
                    "Replaces all disks for the instance"),
  'modify': (SetInstanceParms, ARGS_ONE,
             [DEBUG_OPT, FORCE_OPT,
              cli_option("-m", "--memory", dest="mem",
                         help="Memory size",
                         default=None, type="unit", metavar="<mem>"),
              make_option("-p", "--cpu", dest="vcpus",
                          help="Number of virtual CPUs",
                          default=None, type="int", metavar="<PROC>"),
              make_option("-i", "--ip", dest="ip",
                          help="IP address ('none' or numeric IP)",
                          default=None, type="string", metavar="<ADDRESS>"),
              make_option("-b", "--bridge", dest="bridge",
                          help="Bridge to connect this instance to",
                          default=None, type="string", metavar="<bridge>")
              ],
             "<instance>", "Alters the parameters of an instance"),
  'shutdown': (ShutdownInstance, ARGS_ONE, [DEBUG_OPT],
               "<instance>", "Stops an instance"),
  'startup': (StartupInstance, ARGS_ONE,
              [DEBUG_OPT, FORCE_OPT,
               make_option("-e", "--extra", dest="extra_args",
                           help="Extra arguments for the instance's kernel",
                           default=None, type="string", metavar="<PARAMS>"),
               ],
            "<instance>", "Starts an instance"),
  'activate-disks': (ActivateDisks, ARGS_ONE, [DEBUG_OPT],
                     "<instance>",
                     "Activate an instance's disks"),
  'deactivate-disks': (DeactivateDisks, ARGS_ONE, [DEBUG_OPT],
                       "<instance>",
                       "Deactivate an instance's disks"),
  }

if __name__ == '__main__':
  sys.exit(GenericMain(commands))
