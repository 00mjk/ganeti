#!/usr/bin/python
#

# Copyright (C) 2007, 2008, 2009 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.


"""Tool to upgrade the configuration file.

This code handles only the types supported by simplejson. As an
example, 'set' is a 'list'.

"""


import os
import os.path
import sys
import optparse
import tempfile
import logging
import errno

from ganeti import constants
from ganeti import serializer
from ganeti import utils
from ganeti import cli
from ganeti import bootstrap


# We need to keep filenames locally because they might be renamed between
# versions.
CONFIG_DATA_PATH = constants.DATA_DIR + "/config.data"
SERVER_PEM_PATH = constants.DATA_DIR + "/server.pem"
KNOWN_HOSTS_PATH = constants.DATA_DIR + "/known_hosts"
SSCONF_CLUSTER_NAME_PATH = constants.DATA_DIR + "/ssconf_cluster_name"
SSCONF_CONFIG_VERSION_PATH = constants.DATA_DIR + "/ssconf_config_version"

options = None
args = None

# Unique object to identify calls without default value
NoDefault = object()


class Error(Exception):
  """Generic exception"""
  pass


def SsconfName(key):
  """Returns the file name of an (old) ssconf key.

  """
  return "%s/ssconf_%s" % (constants.DATA_DIR, key)


def ReadFile(file_name, default=NoDefault):
  """Reads a file.

  """
  logging.debug("Reading %s", file_name)
  try:
    fh = open(file_name, 'r')
  except IOError, err:
    if default is not NoDefault and err.errno == errno.ENOENT:
      return default
    raise

  try:
    return fh.read()
  finally:
    fh.close()


def WriteFile(file_name, data):
  """Writes a configuration file.

  """
  logging.debug("Writing %s", file_name)
  utils.WriteFile(file_name=file_name, data=data, mode=0600,
                  dry_run=options.dry_run, backup=True)


def SetupLogging():
  """Configures the logging module.

  """
  formatter = logging.Formatter("%(asctime)s: %(message)s")

  stderr_handler = logging.StreamHandler()
  stderr_handler.setFormatter(formatter)
  if options.debug:
    stderr_handler.setLevel(logging.NOTSET)
  elif options.verbose:
    stderr_handler.setLevel(logging.INFO)
  else:
    stderr_handler.setLevel(logging.CRITICAL)

  root_logger = logging.getLogger("")
  root_logger.setLevel(logging.NOTSET)
  root_logger.addHandler(stderr_handler)


def Cluster12To20(cluster):
  """Upgrades the cluster object from 1.2 to 2.0.

  """
  logging.info("Upgrading the cluster object")
  # Upgrade the configuration version
  if 'config_version' in cluster:
    del cluster['config_version']

  # Add old ssconf keys back to config
  logging.info(" - importing ssconf keys")
  for key in ('master_node', 'master_ip', 'master_netdev', 'cluster_name'):
    if key not in cluster:
      cluster[key] = ReadFile(SsconfName(key)).strip()

  if 'default_hypervisor' not in cluster:
    old_hyp = ReadFile(SsconfName('hypervisor')).strip()
    if old_hyp == "xen-3.0":
      hyp = "xen-pvm"
    elif old_hyp == "xen-hvm-3.1":
      hyp = "xen-hvm"
    elif old_hyp == "fake":
      hyp = "fake"
    else:
      raise Error("Unknown old hypervisor name '%s'" % old_hyp)

    logging.info("Setting the default and enabled hypervisor")
    cluster['default_hypervisor'] = hyp
    cluster['enabled_hypervisors'] = [hyp]

  # hv/be params
  if 'hvparams' not in cluster:
    logging.info(" - adding hvparams")
    cluster['hvparams'] = constants.HVC_DEFAULTS
  if 'beparams' not in cluster:
    logging.info(" - adding beparams")
    cluster['beparams'] = {constants.BEGR_DEFAULT: constants.BEC_DEFAULTS}

  # file storage
  if 'file_storage_dir' not in cluster:
    cluster['file_storage_dir'] = constants.DEFAULT_FILE_STORAGE_DIR


def Node12To20(node):
  """Upgrades a node from 1.2 to 2.0.

  """
  logging.info("Upgrading node %s" % node['name'])
  if 'serial_no' not in node:
    node['serial_no'] = 1
  if 'master_candidate' not in node:
    node['master_candidate'] = True
  for key in 'offline', 'drained':
    if key not in node:
      node[key] = False


def main():
  """Main program.

  """
  global options, args

  program = os.path.basename(sys.argv[0])

  # Option parsing
  parser = optparse.OptionParser(usage="%prog [--debug|--verbose] [--force]")
  parser.add_option('--dry-run', dest='dry_run',
                    action="store_true",
                    help="Try to do the conversion, but don't write"
                         " output file")
  parser.add_option(cli.FORCE_OPT)
  parser.add_option(cli.DEBUG_OPT)
  parser.add_option('-v', '--verbose', dest='verbose',
                    action="store_true",
                    help="Verbose output")
  (options, args) = parser.parse_args()

  SetupLogging()

  # Option checking
  if args:
    raise Error("No arguments expected")

  if not options.force:
    usertext = ("%s MUST be run on the master node. Is this the master"
                " node and are ALL instances down?" % program)
    if not cli.AskUser(usertext):
      sys.exit(1)

  # Check whether it's a Ganeti configuration directory
  if not (os.path.isfile(CONFIG_DATA_PATH) and
          os.path.isfile(SERVER_PEM_PATH) or
          os.path.isfile(KNOWN_HOSTS_PATH)):
    raise Error(("%s does not seem to be a known Ganeti configuration"
                 " directory") % constants.DATA_DIR)

  config_version = ReadFile(SSCONF_CONFIG_VERSION_PATH, "1.2").strip()
  logging.info("Found configuration version %s", config_version)

  config_data = serializer.LoadJson(ReadFile(CONFIG_DATA_PATH))

  # Ganeti 1.2?
  if config_version == "1.2":
    logging.info("Found a Ganeti 1.2 configuration")

    cluster = config_data["cluster"]

    old_config_version = cluster.get("config_version", None)
    logging.info("Found old configuration version %s", old_config_version)
    if old_config_version not in (3, ):
      raise Error("Unsupported configuration version: %s" %
                  old_config_version)
    if 'version' not in config_data:
      config_data['version'] = constants.BuildVersion(2, 0, 0)
    if 'serial_no' not in config_data:
      config_data['serial_no'] = 1

    # Make sure no instance uses remote_raid1 anymore
    remote_raid1_instances = []
    for instance in config_data["instances"]:
      if instance["disk_template"] == "remote_raid1":
        remote_raid1_instances.append(instance["name"])
    if remote_raid1_instances:
      for name in remote_raid1_instances:
        logging.error("Instance %s still using remote_raid1 disk template")
      raise Error("Unable to convert configuration as long as there are"
                  " instances using remote_raid1 disk template")

    # Build content of new known_hosts file
    cluster_name = ReadFile(SSCONF_CLUSTER_NAME_PATH).rstrip()
    cluster_key = cluster['rsahostkeypub']
    known_hosts = "%s ssh-rsa %s\n" % (cluster_name, cluster_key)

    Cluster12To20(cluster)

    # Add node attributes
    logging.info("Upgrading nodes")
    # stable-sort the names to have repeatable runs
    for node_name in utils.NiceSort(config_data['nodes'].keys()):
      Node12To20(config_data['nodes'][node_name])

    # instance changes
    # TODO: add instance upgrade
    for instance in config_data['instances'].values():
      pass

  else:
    logging.info("Found a Ganeti 2.0 configuration")

    if "config_version" in config_data["cluster"]:
      raise Error("Inconsistent configuration: found config_data in"
                  " configuration file")

    known_hosts = None

  try:
    logging.info("Writing configuration file")
    WriteFile(CONFIG_DATA_PATH, serializer.DumpJson(config_data))

    if known_hosts is not None:
      logging.info("Writing SSH known_hosts file (%s)", known_hosts.strip())
      WriteFile(KNOWN_HOSTS_PATH, known_hosts)

    if not options.dry_run:
      if not os.path.exists(constants.RAPI_CERT_FILE):
        bootstrap._GenerateSelfSignedSslCert(constants.RAPI_CERT_FILE)

  except:
    logging.critical("Writing configuration failed. It is proably in an"
                     " inconsistent state and needs manual intervention.")
    raise


if __name__ == "__main__":
  main()

# vim: set foldmethod=marker :
