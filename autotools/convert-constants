#!/usr/bin/python
#

# Copyright (C) 2011 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

"""Script for converting Python constants to Haskell code fragments.

"""

import re

from ganeti import constants
from ganeti import compat

CONSTANT_RE = re.compile("^[A-Z][A-Z0-9_-]+$")


def NameRules(name):
  """Converts the upper-cased Python name to Haskell camelCase.

  """
  name = name.replace("-", "_")
  elems = name.split("_")
  return elems[0].lower() + "".join(e.capitalize() for e in elems[1:])


def StringValueRules(value):
  """Converts a string value from Python to Haskell.

  """
  value = value.encode("string_escape") # escapes backslashes
  value = value.replace("\"", "\\\"")
  return value


def DictKeyName(dict_name, key_name):
  """Converts a dict plus key name to a full name.

  """
  return"%s_%s" % (dict_name, str(key_name).upper())


def HaskellTypeVal(value):
  """Returns the Haskell type and value for a Python value.

  Note that this only work for 'plain' Python types.

  @returns: (string, string) or None, if we can't determine the type.

  """
  if isinstance(value, basestring):
    return ("String", "\"%s\"" % StringValueRules(value))
  elif isinstance(value, int):
    return ("Int", "%d" % value)
  elif isinstance(value, long):
    return ("Integer", "%d" % value)
  elif isinstance(value, float):
    return ("Double", "%f" % value)
  else:
    return None


def ConvertVariable(name, value):
  """Converts a given variable to Haskell code.

  @param name: the Python name
  @param value: the value
  @return: a list of Haskell code lines

  """
  lines = []
  hs_name = NameRules(name)
  hs_typeval = HaskellTypeVal(value)
  if not CONSTANT_RE.match(name):
    lines.append("-- Skipped %s, not constant" % name)
  elif hs_typeval is not None:
    # this is a simple value
    (hs_type, hs_val) = hs_typeval
    lines.append("-- | Converted from Python constant %s" % name)
    lines.append("%s :: %s" % (hs_name, hs_type))
    lines.append("%s = %s" % (hs_name, hs_val))
  elif isinstance(value, dict):
    if value:
      lines.append("-- Following lines come from dictionary %s" % name)
      for k in sorted(value.keys()):
        lines.extend(ConvertVariable(DictKeyName(name, k), value[k]))
  elif isinstance(value, tuple):
    tvs = [HaskellTypeVal(elem) for elem in value]
    if compat.all(e is not None for e in tvs):
      ttypes = ", ".join(e[0] for e in tvs)
      tvals = ", ".join(e[1] for e in tvs)
      lines.append("-- | Converted from Python tuple %s" % name)
      lines.append("%s :: (%s)" % (hs_name, ttypes))
      lines.append("%s = (%s)" % (hs_name, tvals))
    else:
      lines.append("-- Skipped tuple %s, cannot convert all elements" % name)
  else:
    lines.append("-- Skipped %s, %s not handled" % (name, type(value)))
  return lines


def Convert():
  """Converts the constants to Haskell.

  """
  lines = [""]

  all_names = dir(constants)

  for name in all_names:
    value = getattr(constants, name)
    lines.extend(ConvertVariable(name, value))
    lines.append("")

  return "\n".join(lines)


def main():
  print Convert()


if __name__ == "__main__":
  main()
