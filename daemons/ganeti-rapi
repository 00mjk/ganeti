#!/usr/bin/python
#

# Copyright (C) 2006, 2007 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

""" Ganeti Remote API master script.
"""

import glob
import optparse
import sys
import os
import signal

from ganeti import constants
from ganeti import errors
from ganeti import http
from ganeti import rpc
from ganeti import utils
from ganeti.rapi import connector


class RESTRequestHandler(http.HTTPRequestHandler):
  """REST Request Handler Class.

  """
  def setup(self):
    super(RESTRequestHandler, self).setup()
    self._resmap = connector.Mapper()

  def HandleRequest(self):
    """ Handels a request.

    """
    (HandlerClass, items, args) = self._resmap.getController(self.path)
    handler = HandlerClass(self, items, args)

    command = self.command.upper()
    try:
      fn = getattr(handler, command)
    except AttributeError, err:
      raise http.HTTPBadRequest()

    try:
      result = fn()

    except errors.OpPrereqError, err:
      # TODO: "Not found" is not always the correct error. Ganeti's core must
      # differentiate between different error types.
      raise http.HTTPNotFound(message=str(err))

    return result


class RESTHttpServer(http.HTTPServer):
  def serve_forever(self):
    """Handle one request at a time until told to quit."""
    sighandler = utils.SignalHandler([signal.SIGINT, signal.SIGTERM])
    try:
      while not sighandler.called:
        self.handle_request()
    finally:
      sighandler.Reset()


def ParseOptions():
  """Parse the command line options.

  Returns:
    (options, args) as from OptionParser.parse_args()

  """
  parser = optparse.OptionParser(description="Ganeti Remote API",
                    usage="%prog [-d] [-p port]",
                    version="%%prog (ganeti) %s" %
                                 constants.RAPI_VERSION)
  parser.add_option("-d", "--debug", dest="debug",
                    help="Enable some debug messages",
                    default=False, action="store_true")
  parser.add_option("-p", "--port", dest="port",
                    help="Port to run API (%s default)." %
                                 constants.RAPI_PORT,
                    default=constants.RAPI_PORT, type="int")
  parser.add_option("-S", "--https", dest="ssl",
                    help="Secure HTTP protocol with SSL",
                    default=False, action="store_true")
  parser.add_option("-K", "--ssl-key", dest="ssl_key",
                    help="SSL key",
                    default=None, type="string")
  parser.add_option("-C", "--ssl-cert", dest="ssl_cert",
                    help="SSL certificate",
                    default=None, type="string")
  parser.add_option("-f", "--foreground", dest="fork",
                    help="Don't detach from the current terminal",
                    default=True, action="store_false")

  options, args = parser.parse_args()

  if len(args) != 0:
    print >> sys.stderr, "Usage: %s [-d] [-p port]" % sys.argv[0]
    sys.exit(1)

  if options.ssl and not (options.ssl_cert and options.ssl_key):
    print >> sys.stderr, ("For secure mode please provide "
                         "--ssl-key and --ssl-cert arguments")
    sys.exit(1)

  return options, args


def main():
  """Main function.

  """
  options, args = ParseOptions()

  if options.fork:
    utils.Daemonize(logfile=constants.LOG_RAPISERVER)

  utils.WritePidFile(constants.RAPI_PID)

  log_fd = open(constants.LOG_RAPIACCESS, 'a')
  try:
    apache_log = http.ApacheLogfile(log_fd)
    httpd = RESTHttpServer(("", options.port), RESTRequestHandler,
                           httplog=apache_log)
    try:
      httpd.serve_forever()
    finally:
      httpd.server_close()
      utils.RemovePidFile(constants.RAPI_PID)

  finally:
    log_fd.close()

  sys.exit(0)


if __name__ == '__main__':
  main()
