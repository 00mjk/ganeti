#!/usr/bin/python
#

# Copyright (C) 2006, 2007 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.


"""Ganeti node daemon"""

# functions in this module need to have a given name structure, so:
# pylint: disable-msg=C0103

import os
import sys
import traceback
import SocketServer
import errno
import logging
import signal

from optparse import OptionParser

from ganeti import backend
from ganeti import logger
from ganeti import constants
from ganeti import objects
from ganeti import errors
from ganeti import jstore
from ganeti import http
from ganeti import utils


queue_lock = None


def _RequireJobQueueLock(fn):
  """Decorator for job queue manipulating functions.

  """
  QUEUE_LOCK_TIMEOUT = 10

  def wrapper(*args, **kwargs):
    # Locking in exclusive, blocking mode because there could be several
    # children running at the same time. Waiting up to 10 seconds.
    queue_lock.Exclusive(blocking=True, timeout=QUEUE_LOCK_TIMEOUT)
    try:
      return fn(*args, **kwargs)
    finally:
      queue_lock.Unlock()

  return wrapper


class NodeDaemonRequestHandler(http.HTTPRequestHandler):
  """The server implementation.

  This class holds all methods exposed over the RPC interface.

  """
  def HandleRequest(self):
    """Handle a request.

    """
    if self.command.upper() != "PUT":
      raise http.HTTPBadRequest()

    path = self.path
    if path.startswith("/"):
      path = path[1:]

    method = getattr(self, "perspective_%s" % path, None)
    if method is None:
      raise httperror.HTTPNotFound()

    try:
      try:
        return method(self.post_data)
      except:
        logging.exception("Error in RPC call")
        raise
    except errors.QuitGanetiException, err:
      # Tell parent to quit
      os.kill(self.server.noded_pid, signal.SIGTERM)

  # the new block devices  --------------------------

  @staticmethod
  def perspective_blockdev_create(params):
    """Create a block device.

    """
    bdev_s, size, owner, on_primary, info = params
    bdev = objects.Disk.FromDict(bdev_s)
    if bdev is None:
      raise ValueError("can't unserialize data!")
    return backend.CreateBlockDevice(bdev, size, owner, on_primary, info)

  @staticmethod
  def perspective_blockdev_remove(params):
    """Remove a block device.

    """
    bdev_s = params[0]
    bdev = objects.Disk.FromDict(bdev_s)
    return backend.RemoveBlockDevice(bdev)

  @staticmethod
  def perspective_blockdev_rename(params):
    """Remove a block device.

    """
    devlist = [(objects.Disk.FromDict(ds), uid) for ds, uid in params]
    return backend.RenameBlockDevices(devlist)

  @staticmethod
  def perspective_blockdev_assemble(params):
    """Assemble a block device.

    """
    bdev_s, owner, on_primary = params
    bdev = objects.Disk.FromDict(bdev_s)
    if bdev is None:
      raise ValueError("can't unserialize data!")
    return backend.AssembleBlockDevice(bdev, owner, on_primary)

  @staticmethod
  def perspective_blockdev_shutdown(params):
    """Shutdown a block device.

    """
    bdev_s = params[0]
    bdev = objects.Disk.FromDict(bdev_s)
    if bdev is None:
      raise ValueError("can't unserialize data!")
    return backend.ShutdownBlockDevice(bdev)

  @staticmethod
  def perspective_blockdev_addchildren(params):
    """Add a child to a mirror device.

    Note: this is only valid for mirror devices. It's the caller's duty
    to send a correct disk, otherwise we raise an error.

    """
    bdev_s, ndev_s = params
    bdev = objects.Disk.FromDict(bdev_s)
    ndevs = [objects.Disk.FromDict(disk_s) for disk_s in ndev_s]
    if bdev is None or ndevs.count(None) > 0:
      raise ValueError("can't unserialize data!")
    return backend.MirrorAddChildren(bdev, ndevs)

  @staticmethod
  def perspective_blockdev_removechildren(params):
    """Remove a child from a mirror device.

    This is only valid for mirror devices, of course. It's the callers
    duty to send a correct disk, otherwise we raise an error.

    """
    bdev_s, ndev_s = params
    bdev = objects.Disk.FromDict(bdev_s)
    ndevs = [objects.Disk.FromDict(disk_s) for disk_s in ndev_s]
    if bdev is None or ndevs.count(None) > 0:
      raise ValueError("can't unserialize data!")
    return backend.MirrorRemoveChildren(bdev, ndevs)

  @staticmethod
  def perspective_blockdev_getmirrorstatus(params):
    """Return the mirror status for a list of disks.

    """
    disks = [objects.Disk.FromDict(dsk_s)
            for dsk_s in params]
    return backend.GetMirrorStatus(disks)

  @staticmethod
  def perspective_blockdev_find(params):
    """Expose the FindBlockDevice functionality for a disk.

    This will try to find but not activate a disk.

    """
    disk = objects.Disk.FromDict(params[0])
    return backend.FindBlockDevice(disk)

  @staticmethod
  def perspective_blockdev_snapshot(params):
    """Create a snapshot device.

    Note that this is only valid for LVM disks, if we get passed
    something else we raise an exception. The snapshot device can be
    remove by calling the generic block device remove call.

    """
    cfbd = objects.Disk.FromDict(params[0])
    return backend.SnapshotBlockDevice(cfbd)

  @staticmethod
  def perspective_blockdev_grow(params):
    """Grow a stack of devices.

    """
    cfbd = objects.Disk.FromDict(params[0])
    amount = params[1]
    return backend.GrowBlockDevice(cfbd, amount)

  @staticmethod
  def perspective_blockdev_close(params):
    """Closes the given block devices.

    """
    disks = [objects.Disk.FromDict(cf) for cf in params]
    return backend.CloseBlockDevices(disks)

  # export/import  --------------------------

  @staticmethod
  def perspective_snapshot_export(params):
    """Export a given snapshot.

    """
    disk = objects.Disk.FromDict(params[0])
    dest_node = params[1]
    instance = objects.Instance.FromDict(params[2])
    cluster_name = params[3]
    return backend.ExportSnapshot(disk, dest_node, instance, cluster_name)

  @staticmethod
  def perspective_finalize_export(params):
    """Expose the finalize export functionality.

    """
    instance = objects.Instance.FromDict(params[0])
    snap_disks = [objects.Disk.FromDict(str_data)
                  for str_data in params[1]]
    return backend.FinalizeExport(instance, snap_disks)

  @staticmethod
  def perspective_export_info(params):
    """Query information about an existing export on this node.

    The given path may not contain an export, in which case we return
    None.

    """
    path = params[0]
    einfo = backend.ExportInfo(path)
    if einfo is None:
      return einfo
    return einfo.Dumps()

  @staticmethod
  def perspective_export_list(params):
    """List the available exports on this node.

    Note that as opposed to export_info, which may query data about an
    export in any path, this only queries the standard Ganeti path
    (constants.EXPORT_DIR).

    """
    return backend.ListExports()

  @staticmethod
  def perspective_export_remove(params):
    """Remove an export.

    """
    export = params[0]
    return backend.RemoveExport(export)

  # volume  --------------------------

  @staticmethod
  def perspective_volume_list(params):
    """Query the list of logical volumes in a given volume group.

    """
    vgname = params[0]
    return backend.GetVolumeList(vgname)

  @staticmethod
  def perspective_vg_list(params):
    """Query the list of volume groups.

    """
    return backend.ListVolumeGroups()

  # bridge  --------------------------

  @staticmethod
  def perspective_bridges_exist(params):
    """Check if all bridges given exist on this node.

    """
    bridges_list = params[0]
    return backend.BridgesExist(bridges_list)

  # instance  --------------------------

  @staticmethod
  def perspective_instance_os_add(params):
    """Install an OS on a given instance.

    """
    inst_s, os_disk, swap_disk = params
    inst = objects.Instance.FromDict(inst_s)
    return backend.AddOSToInstance(inst, os_disk, swap_disk)

  @staticmethod
  def perspective_instance_run_rename(params):
    """Runs the OS rename script for an instance.

    """
    inst_s, old_name, os_disk, swap_disk = params
    inst = objects.Instance.FromDict(inst_s)
    return backend.RunRenameInstance(inst, old_name, os_disk, swap_disk)

  @staticmethod
  def perspective_instance_os_import(params):
    """Run the import function of an OS onto a given instance.

    """
    inst_s, os_disk, swap_disk, src_node, src_image, cluster_name = params
    inst = objects.Instance.FromDict(inst_s)
    return backend.ImportOSIntoInstance(inst, os_disk, swap_disk,
                                        src_node, src_image, cluster_name)

  @staticmethod
  def perspective_instance_shutdown(params):
    """Shutdown an instance.

    """
    instance = objects.Instance.FromDict(params[0])
    return backend.ShutdownInstance(instance)

  @staticmethod
  def perspective_instance_start(params):
    """Start an instance.

    """
    instance = objects.Instance.FromDict(params[0])
    extra_args = params[1]
    return backend.StartInstance(instance, extra_args)

  @staticmethod
  def perspective_instance_migrate(params):
    """Migrates an instance.

    """
    instance, target, live = params
    return backend.MigrateInstance(instance, target, live)

  @staticmethod
  def perspective_instance_reboot(params):
    """Reboot an instance.

    """
    instance = objects.Instance.FromDict(params[0])
    reboot_type = params[1]
    extra_args = params[2]
    return backend.RebootInstance(instance, reboot_type, extra_args)

  @staticmethod
  def perspective_instance_info(params):
    """Query instance information.

    """
    return backend.GetInstanceInfo(params[0])

  @staticmethod
  def perspective_all_instances_info(params):
    """Query information about all instances.

    """
    return backend.GetAllInstancesInfo()

  @staticmethod
  def perspective_instance_list(params):
    """Query the list of running instances.

    """
    return backend.GetInstanceList()

  # node --------------------------

  @staticmethod
  def perspective_node_tcp_ping(params):
    """Do a TcpPing on the remote node.

    """
    return utils.TcpPing(params[1], params[2], timeout=params[3],
                         live_port_needed=params[4], source=params[0])

  @staticmethod
  def perspective_node_info(params):
    """Query node information.

    """
    vgname = params[0]
    return backend.GetNodeInfo(vgname)

  @staticmethod
  def perspective_node_add(params):
    """Complete the registration of this node in the cluster.

    """
    return backend.AddNode(params[0], params[1], params[2],
                           params[3], params[4], params[5])

  @staticmethod
  def perspective_node_verify(params):
    """Run a verify sequence on this node.

    """
    return backend.VerifyNode(params[0], params[1])

  @staticmethod
  def perspective_node_start_master(params):
    """Promote this node to master status.

    """
    return backend.StartMaster(params[0])

  @staticmethod
  def perspective_node_stop_master(params):
    """Demote this node from master status.

    """
    return backend.StopMaster(params[0])

  @staticmethod
  def perspective_node_leave_cluster(params):
    """Cleanup after leaving a cluster.

    """
    return backend.LeaveCluster()

  @staticmethod
  def perspective_node_volumes(params):
    """Query the list of all logical volume groups.

    """
    return backend.NodeVolumes()

  # cluster --------------------------

  @staticmethod
  def perspective_version(params):
    """Query version information.

    """
    return constants.PROTOCOL_VERSION

  @staticmethod
  def perspective_upload_file(params):
    """Upload a file.

    Note that the backend implementation imposes strict rules on which
    files are accepted.

    """
    return backend.UploadFile(*params)

  @staticmethod
  def perspective_master_info(params):
    """Query master information.

    """
    return backend.GetMasterInfo()

  # os -----------------------

  @staticmethod
  def perspective_os_diagnose(params):
    """Query detailed information about existing OSes.

    """
    return [os.ToDict() for os in backend.DiagnoseOS()]

  @staticmethod
  def perspective_os_get(params):
    """Query information about a given OS.

    """
    name = params[0]
    try:
      os_obj = backend.OSFromDisk(name)
    except errors.InvalidOS, err:
      os_obj = objects.OS.FromInvalidOS(err)
    return os_obj.ToDict()

  # hooks -----------------------

  @staticmethod
  def perspective_hooks_runner(params):
    """Run hook scripts.

    """
    hpath, phase, env = params
    hr = backend.HooksRunner()
    return hr.RunHooks(hpath, phase, env)

  # iallocator -----------------

  @staticmethod
  def perspective_iallocator_runner(params):
    """Run an iallocator script.

    """
    name, idata = params
    iar = backend.IAllocatorRunner()
    return iar.Run(name, idata)

  # test -----------------------

  @staticmethod
  def perspective_test_delay(params):
    """Run test delay.

    """
    duration = params[0]
    return utils.TestDelay(duration)

  # file storage ---------------

  @staticmethod
  def perspective_file_storage_dir_create(params):
    """Create the file storage directory.

    """
    file_storage_dir = params[0]
    return backend.CreateFileStorageDir(file_storage_dir)

  @staticmethod
  def perspective_file_storage_dir_remove(params):
    """Remove the file storage directory.

    """
    file_storage_dir = params[0]
    return backend.RemoveFileStorageDir(file_storage_dir)

  @staticmethod
  def perspective_file_storage_dir_rename(params):
    """Rename the file storage directory.

    """
    old_file_storage_dir = params[0]
    new_file_storage_dir = params[1]
    return backend.RenameFileStorageDir(old_file_storage_dir,
                                        new_file_storage_dir)

  # jobs ------------------------

  @staticmethod
  @_RequireJobQueueLock
  def perspective_jobqueue_update(params):
    """Update job queue.

    """
    (file_name, content) = params
    return backend.JobQueueUpdate(file_name, content)

  @staticmethod
  @_RequireJobQueueLock
  def perspective_jobqueue_purge(params):
    """Purge job queue.

    """
    return backend.JobQueuePurge()

  @staticmethod
  @_RequireJobQueueLock
  def perspective_jobqueue_rename(params):
    """Rename a job queue file.

    """
    (old, new) = params

    return backend.JobQueueRename(old, new)


class NodeDaemonHttpServer(http.HTTPServer):
  def __init__(self, server_address):
    http.HTTPServer.__init__(self, server_address, NodeDaemonRequestHandler)
    self.noded_pid = os.getpid()

  def serve_forever(self):
    """Handle requests until told to quit."""
    sighandler = utils.SignalHandler([signal.SIGINT, signal.SIGTERM])
    try:
      while not sighandler.called:
        self.handle_request()
      # TODO: There could be children running at this point
    finally:
      sighandler.Reset()


class ForkingHTTPServer(SocketServer.ForkingMixIn, NodeDaemonHttpServer):
  """Forking HTTP Server.

  This inherits from ForkingMixIn and HTTPServer in order to fork for each
  request we handle. This allows more requests to be handled concurrently.

  """


def ParseOptions():
  """Parse the command line options.

  Returns:
    (options, args) as from OptionParser.parse_args()

  """
  parser = OptionParser(description="Ganeti node daemon",
                        usage="%prog [-f] [-d]",
                        version="%%prog (ganeti) %s" %
                        constants.RELEASE_VERSION)

  parser.add_option("-f", "--foreground", dest="fork",
                    help="Don't detach from the current terminal",
                    default=True, action="store_false")
  parser.add_option("-d", "--debug", dest="debug",
                    help="Enable some debug messages",
                    default=False, action="store_true")
  options, args = parser.parse_args()
  return options, args


def main():
  """Main function for the node daemon.

  """
  global queue_lock

  options, args = ParseOptions()
  utils.debug = options.debug
  for fname in (constants.SSL_CERT_FILE,):
    if not os.path.isfile(fname):
      print "config %s not there, will not run." % fname
      sys.exit(5)

  try:
    port = utils.GetNodeDaemonPort()
    pwdata = utils.GetNodeDaemonPassword()
  except errors.ConfigurationError, err:
    print "Cluster configuration incomplete: '%s'" % str(err)
    sys.exit(5)

  # create the various SUB_RUN_DIRS, if not existing, so that we handle the
  # situation where RUN_DIR is tmpfs
  for dir_name in constants.SUB_RUN_DIRS:
    if not os.path.exists(dir_name):
      try:
        os.mkdir(dir_name, 0755)
      except EnvironmentError, err:
        if err.errno != errno.EEXIST:
          print ("Node setup wrong, cannot create directory %s: %s" %
                 (dir_name, err))
          sys.exit(5)
    if not os.path.isdir(dir_name):
      print ("Node setup wrong, %s is not a directory" % dir_name)
      sys.exit(5)

  # become a daemon
  if options.fork:
    utils.Daemonize(logfile=constants.LOG_NODESERVER)

  utils.WritePidFile(constants.NODED_PID)

  logger.SetupLogging(logfile=constants.LOG_NODESERVER, debug=options.debug,
                      stderr_logging=not options.fork)
  logging.info("ganeti node daemon startup")

  # Prepare job queue
  queue_lock = jstore.InitAndVerifyQueue(must_lock=False)

  if options.fork:
    server = ForkingHTTPServer(('', port))
  else:
    server = NodeDaemonHttpServer(('', port))

  try:
    server.serve_forever()
  finally:
    utils.RemovePidFile(constants.NODED_PID)


if __name__ == '__main__':
  main()
